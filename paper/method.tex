\section{Method}
\label{sec:method}
In this section, we discuss how we drew on a publicly-available data set
(Section~\ref{sec:data-collection}) and used Heninger and Halderman's
fastgcd~\cite{fastgcd} tool to analyze the public keys that we extracted from
this data set (Section~\ref{sec:vulnerable-keys}).

\subsection{Data collection}
\label{sec:data-collection}
The Tor Project archives data about Tor relays on its CollecTor
platform~\cite{collector}, allowing researchers to learn what relays were online
at any point in the past.  Drawing on this data source, we compiled a set of RSA
keys by downloading all server descriptors from December 2005 to December 2016,
and extracting the identity and onion keys using the Stem Python
library~\cite{stem}.  Table~\ref{tab:dataset} provides an overview of the
resulting data set---approximately 200 GB of unzipped data.  Our 3.7 million
public keys span 11 years and were created on one million IP addresses.
Our dataset, basically a subset of the data archived on CollecTor plus
easy-to-analyze key information, is publicly available.

\begin{table}[t]
	\centering
	\begin{tabular}{l r}
	\toprule
	First key published & 2005-12 \\
	Last key published & 2016-12 \\
	Number of relays (by IP address) & 1,083,805 \\
	\midrule
	Number of onion keys & 3,174,859 \\
	Number of identity keys & 588,945 \\
	\midrule
	Total number of public keys & 3,763,804 \\
	\bottomrule
	\end{tabular}
	\caption{An overview of our RSA public key data set.}
	\label{tab:dataset}
\end{table}

\subsection{Finding vulnerable keys}
\label{sec:vulnerable-keys}
To detect weak, potentially factorable keys in the Tor network, we used Heninger
and Halderman's tool fastgcd~\cite{fastgcd}, which takes as input a set of
moduli from public keys and then computes the pair-wise greatest common divisor
of these moduli.  Fastgcd's C implementation is based on a quasilinear-time
algorithm for factoring a set of integers into their co-primes.  We used the
PyCrypto library~\cite{pycrypto} to turn Tor's PKCS\#1-padded, PEM-encoded keys
into fastgcd's expected format, which is hex-encoded moduli.  Running fastgcd
over our data set took less than 20 minutes on a machine with an eight-core 2.8
GHz Intel Xeon E5 2680 v2 processor, and 256 GB of RAM.

fastgcd benefits from having a pool of moduli that's as large as possible because 
``. . . with a larger collection of inputs the algorithm has a larger 
factor base to use on each key''~\cite{Heninger2012a}.  
To that end, we reached out to Nadia Heninger's group at University of Pennsylvania, 
and they graciously re-ran our experiment on a set of 129 million 
moduli. The number of Tor weak keys did not go up, but 
this experiment gave us more confidence that we had not missed any weak keys.
